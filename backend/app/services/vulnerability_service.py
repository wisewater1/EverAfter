import re
import uuid
from typing import List, Dict, Any, Optional
from datetime import datetime, timedelta
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.services.akashic_service import akashic
from app.models.engram import DailyQuestionResponse

class VulnerabilityService:
    def __init__(self, session: AsyncSession = None):
        self.session = session
        # Mock CVE data inspired by Exploit Tracker
        self.tracked_cves = [
            {
                "id": "cve-" + str(uuid.uuid4())[:8],
                "cveId": "CVE-2024-31091",
                "title": "Authentication Bypass in Legacy Module",
                "severity": "critical",
                "cvssScore": 9.8,
                "affectedComponent": "Auth Service v2.1",
                "status": "patched",
                "publishedDate": "2024-03-15",
                "description": "Allows unauthenticated users to bypass MFA."
            },
            {
                "id": "cve-" + str(uuid.uuid4())[:8],
                "cveId": "CVE-2024-55821",
                "title": "Memory Corruption in Neural Pipeline",
                "severity": "high",
                "cvssScore": 8.1,
                "affectedComponent": "Akashic Processor",
                "status": "open",
                "publishedDate": "2024-05-20",
                "description": "Buffer overflow in engram vectorization engine."
            },
            {
                "id": "cve-" + str(uuid.uuid4())[:8],
                "cveId": "CVE-2024-22119",
                "title": "Unauthorized Engram Restoration",
                "severity": "medium",
                "cvssScore": 6.5,
                "affectedComponent": "Saint Runtime Core",
                "status": "mitigated",
                "publishedDate": "2024-02-10",
                "description": "Information disclosure via malformed engram IDs."
            }
        ]

    async def get_latest_vulnerabilities(self) -> List[Dict[str, Any]]:
        """Return the current list of tracked CVEs."""
        return self.tracked_cves

    async def run_akashic_audit(self, user_id: str) -> List[Dict[str, Any]]:
        """
        Scan Akashic records for PII patterns, leaks, or adversarial content.
        """
        findings = []
        
        # 1. Scan Global Akashic Record (Shared Memory)
        memories = akashic.memories
        for memory in memories:
            # Check for PII patterns
            content = memory.get("content", "")
            pii_leaks = self._scan_text_for_pii(content)
            if pii_leaks:
                findings.append({
                    "id": str(uuid.uuid4()),
                    "type": "pii_leak",
                    "severity": "high",
                    "message": f"PII detected in Akashic Record: {', '.join(pii_leaks)}",
                    "timestamp": memory.get("timestamp"),
                    "details": f"Memory ID: {memory.get('id')}",
                    "content_snippet": content[:50] + "..."
                })

        # 2. Scan DB Engrams (DailyQuestionResponse) if session and user_id are provided
        if self.session and user_id:
            try:
                user_uuid = uuid.UUID(user_id) if isinstance(user_id, str) else user_id
                stmt = select(DailyQuestionResponse).where(DailyQuestionResponse.user_id == user_uuid)
                result = await self.session.execute(stmt)
                engrams = result.scalars().all()
                
                for engram in engrams:
                    pii_leaks = self._scan_text_for_pii(engram.response_text)
                    if pii_leaks:
                        findings.append({
                            "id": str(uuid.uuid4()),
                            "type": "pii_leak",
                            "severity": "medium",
                            "message": f"PII detected in Personality Engram: {', '.join(pii_leaks)}",
                            "timestamp": engram.created_at.isoformat() if engram.created_at else None,
                            "details": f"Engram ID: {engram.id}",
                            "content_snippet": engram.response_text[:50] + "..."
                        })
            except Exception as e:
                print(f"Error auditing DB engrams: {e}")

        return findings

    def _scan_text_for_pii(self, text: str) -> List[str]:
        """
        Regex-based PII + PHI scanner.
        Covers standard PII and HIPAA-designated Protected Health Information (PHI).
        §164.514(b)(2) — 18 types of PHI identifiers.
        """
        leaks = []
        t = text.lower()

        # ── Standard PII ────────────────────────────────────────────────
        if re.search(r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}', text):
            leaks.append("Email Address")
        if re.search(r'\b\d{3}-\d{2}-\d{4}\b', text):
            leaks.append("SSN/Identifier [PHI]")
        if re.search(r'\b\d{4}[- ]?\d{4}[- ]?\d{4}[- ]?\d{4}\b', text):
            leaks.append("Credit Card Number")

        # ── HIPAA PHI — Identifiers §164.514(b)(2)(i) ───────────────────
        # Medical Record Numbers (MRN-style: MRN followed by digits)
        if re.search(r'\bMRN[\s:]*\d+\b', text, re.IGNORECASE):
            leaks.append("Medical Record Number [PHI]")
        # Health Plan / Insurance IDs
        if re.search(r'\b(health\s*plan|insurance)\s*(id|number|#)[\s:]*[A-Z0-9]{6,}\b', text, re.IGNORECASE):
            leaks.append("Health Plan ID [PHI]")
        # Dates of service / admission
        if re.search(r'\b(date of (service|admission|discharge|birth|death))[\s:]*\d', text, re.IGNORECASE):
            leaks.append("Care Date [PHI]")
        # Phone numbers
        if re.search(r'\b(\+?1[\s.-]?)?\(?\d{3}\)?[\s.-]?\d{3}[\s.-]?\d{4}\b', text):
            leaks.append("Phone Number [PHI]")
        # Geographic data (zip codes only — full address is PHI)
        if re.search(r'\b\d{5}(-\d{4})?\b', text):
            leaks.append("ZIP Code [PHI]")

        # ── HIPAA PHI — Clinical Data ────────────────────────────────────
        # ICD-10/CPT codes
        if re.search(r'\b[A-Z]\d{2}\.?\d{0,2}\b', text):
            leaks.append("ICD/CPT Code [PHI]")
        # Biometric health data keywords
        biometric_keywords = [
            r'\bheart[\s_]?rate\b', r'\bblood[\s_]?pressure\b', r'\bblood[\s_]?glucose\b',
            r'\bbmi\b', r'\bhba1c\b', r'\bo2[\s_]?sat(uration)?\b', r'\bcholesterol\b',
        ]
        for pattern in biometric_keywords:
            if re.search(pattern, t):
                leaks.append("Biometric Identifier [PHI]")
                break
        # Medication / prescription mentions
        medication_keywords = [
            r'\b(metformin|lisinopril|atorvastatin|insulin|warfarin|amoxicillin|sertraline|omeprazole|gabapentin|amlodipine)\b',
            r'\b(prescribed|prescription|dosage|mg\b|tablet|capsule)\b',
        ]
        for pattern in medication_keywords:
            if re.search(pattern, t):
                leaks.append("Prescription/Medication [PHI]")
                break
        # Diagnosis / condition mentions
        clinical_keywords = [
            r'\b(diagnosis|diagnosed with|condition:|symptom|allergy|allergic to|icd\b)\b',
            r'\b(diabetes|hypertension|cancer|depression|anxiety|asthma|copd|ckd|hiv|covid)\b',
        ]
        for pattern in clinical_keywords:
            if re.search(pattern, t):
                leaks.append("Clinical Condition/Diagnosis [PHI]")
                break

        # ── Adversarial Prompt Injection ─────────────────────────────────
        if "REPLACE SYSTEM PROMPT" in text.upper() or "IGNORE PREVIOUS INSTRUCTIONS" in text.upper():
            leaks.append("Adversarial Instruction")

        # Deduplicate while preserving order
        seen: set = set()
        return [x for x in leaks if not (x in seen or seen.add(x))]  # type: ignore[func-returns-value]

    def _get_phi_severity(self, leak_types: List[str]) -> str:
        """Map detected PHI types to a severity level."""
        critical = {"SSN/Identifier [PHI]", "Medical Record Number [PHI]", "Health Plan ID [PHI]"}
        high = {"Biometric Identifier [PHI]", "Clinical Condition/Diagnosis [PHI]", "Prescription/Medication [PHI]", "ICD/CPT Code [PHI]"}
        for leak in leak_types:
            if leak in critical:
                return "critical"
        for leak in leak_types:
            if leak in high:
                return "high"
        return "medium"

    async def run_hipaa_audit(self, user_id: str) -> List[Dict[str, Any]]:
        """
        HIPAA-specific audit: scans Akashic records and engrams for PHI exposure.
        Invoked by St. Anthony (Audit Officer) under §164.312(b).
        """
        findings = await self.run_akashic_audit(user_id)
        # Re-classify any 'pii_leak' findings as HIPAA PHI where appropriate
        for f in findings:
            phi_types = [t for t in f.get("details_list", []) if "[PHI]" in t]
            if phi_types:
                f["type"] = "hipaa_phi_exposure"
                f["severity"] = self._get_phi_severity(phi_types)
                f["hipaa_rule"] = "§164.514(b) — PHI De-identification Required"
            f.pop("details_list", None)
        return findings

    async def perform_full_security_scan(self, user_id: str) -> Dict[str, Any]:
        """Execute all security checks and return a summary."""
        cves = await self.get_latest_vulnerabilities()
        findings = await self.run_akashic_audit(user_id)
        
        return {
            "timestamp": datetime.utcnow().isoformat(),
            "status": "critical" if any(f["severity"] == "critical" for f in findings) else "active",
            "findings_count": len(findings),
            "findings": findings,
            "vulnerabilities": cves,
            "system_integrity": 95 if not findings else max(40, 95 - (len(findings) * 10))
        }

vulnerability_service = VulnerabilityService()
