import re
import uuid
from typing import List, Dict, Any, Optional
from datetime import datetime, timedelta
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.services.akashic_service import akashic
from app.models.engram import DailyQuestionResponse

class VulnerabilityService:
    def __init__(self, session: AsyncSession = None):
        self.session = session
        # Mock CVE data inspired by Exploit Tracker
        self.tracked_cves = [
            {
                "id": "cve-" + str(uuid.uuid4())[:8],
                "cveId": "CVE-2024-31091",
                "title": "Authentication Bypass in Legacy Module",
                "severity": "critical",
                "cvssScore": 9.8,
                "affectedComponent": "Auth Service v2.1",
                "status": "patched",
                "publishedDate": "2024-03-15",
                "description": "Allows unauthenticated users to bypass MFA."
            },
            {
                "id": "cve-" + str(uuid.uuid4())[:8],
                "cveId": "CVE-2024-55821",
                "title": "Memory Corruption in Neural Pipeline",
                "severity": "high",
                "cvssScore": 8.1,
                "affectedComponent": "Akashic Processor",
                "status": "open",
                "publishedDate": "2024-05-20",
                "description": "Buffer overflow in engram vectorization engine."
            },
            {
                "id": "cve-" + str(uuid.uuid4())[:8],
                "cveId": "CVE-2024-22119",
                "title": "Unauthorized Engram Restoration",
                "severity": "medium",
                "cvssScore": 6.5,
                "affectedComponent": "Saint Runtime Core",
                "status": "mitigated",
                "publishedDate": "2024-02-10",
                "description": "Information disclosure via malformed engram IDs."
            }
        ]

    async def get_latest_vulnerabilities(self) -> List[Dict[str, Any]]:
        """Return the current list of tracked CVEs."""
        return self.tracked_cves

    async def run_akashic_audit(self, user_id: str) -> List[Dict[str, Any]]:
        """
        Scan Akashic records for PII patterns, leaks, or adversarial content.
        """
        findings = []
        
        # 1. Scan Global Akashic Record (Shared Memory)
        memories = akashic.memories
        for memory in memories:
            # Check for PII patterns
            content = memory.get("content", "")
            pii_leaks = self._scan_text_for_pii(content)
            if pii_leaks:
                findings.append({
                    "id": str(uuid.uuid4()),
                    "type": "pii_leak",
                    "severity": "high",
                    "message": f"PII detected in Akashic Record: {', '.join(pii_leaks)}",
                    "timestamp": memory.get("timestamp"),
                    "details": f"Memory ID: {memory.get('id')}",
                    "content_snippet": content[:50] + "..."
                })

        # 2. Scan DB Engrams (DailyQuestionResponse) if session and user_id are provided
        if self.session and user_id:
            try:
                user_uuid = uuid.UUID(user_id) if isinstance(user_id, str) else user_id
                stmt = select(DailyQuestionResponse).where(DailyQuestionResponse.user_id == user_uuid)
                result = await self.session.execute(stmt)
                engrams = result.scalars().all()
                
                for engram in engrams:
                    pii_leaks = self._scan_text_for_pii(engram.response_text)
                    if pii_leaks:
                        findings.append({
                            "id": str(uuid.uuid4()),
                            "type": "pii_leak",
                            "severity": "medium",
                            "message": f"PII detected in Personality Engram: {', '.join(pii_leaks)}",
                            "timestamp": engram.created_at.isoformat() if engram.created_at else None,
                            "details": f"Engram ID: {engram.id}",
                            "content_snippet": engram.response_text[:50] + "..."
                        })
            except Exception as e:
                print(f"Error auditing DB engrams: {e}")

        return findings

    def _scan_text_for_pii(self, text: str) -> List[str]:
        """Simple regex-based PII scanner."""
        leaks = []
        
        # Email patterns
        if re.search(r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}', text):
            leaks.append("Email Address")
        
        # SSN patterns (simple 000-00-0000)
        if re.search(r'\d{3}-\d{2}-\d{4}', text):
            leaks.append("SSN/Identifier")
            
        # Credit Card patterns
        if re.search(r'\d{4}-\d{4}-\d{4}-\d{4}', text):
            leaks.append("Credit Card Number")
            
        # Common adversarial patterns
        if "REPLACE SYSTEM PROMPT" in text.upper() or "IGNORE PREVIOUS INSTRUCTIONS" in text.upper():
            leaks.append("Adversarial Instruction")
            
        return leaks

    async def perform_full_security_scan(self, user_id: str) -> Dict[str, Any]:
        """Execute all security checks and return a summary."""
        cves = await self.get_latest_vulnerabilities()
        findings = await self.run_akashic_audit(user_id)
        
        return {
            "timestamp": datetime.utcnow().isoformat(),
            "status": "critical" if any(f["severity"] == "critical" for f in findings) else "active",
            "findings_count": len(findings),
            "findings": findings,
            "vulnerabilities": cves,
            "system_integrity": 95 if not findings else max(40, 95 - (len(findings) * 10))
        }

vulnerability_service = VulnerabilityService()
